package com.github.mineGeek.ZoneReset.Markers;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;

import com.github.mineGeek.ZoneReset.Data.Zone;

/**
 * Static class for managing Markers which highlight cuboid regions
 * @author Moí
 *
 */
public class Markers {

	/**
	 * list of markers we are currently working with.
	 * format: Map< Player Name, List of markers for player>
	 */
	private static Map<String, List<Marker> > markers = new HashMap<String, List<Marker>>();
	
	/**
	 * A sort of hack that prevents errors being generated by disabling plugin (which
	 * closes out this classes resources) when this class had never been called. Sure, there 
	 * will be a better way of doing this, but really... 
	 */
	public static boolean enabled;
	
	
	/**
	 * Shows cuboid to player.
	 * @param p
	 * @param ne
	 * @param sw
	 */
	public static void showZoneBoundaries( Player p, Location ne, Location sw ) {
		
		boolean withFlags = true;
		
		/**
		 * Hide previous markers for shits and giggles
		 */
		if ( markers.containsKey( p.getName()) && !markers.get( p.getName() ).isEmpty() ) {
			hideZoneBoundaries( p );
		}
		
		/**
		 * If they aren't in edit mode... just go home.
		 */
		if ( !p.hasMetadata("zr") ) return;
		if ( ne == null && sw == null ) return;
		
		/**
		 * Are our locations on the same planet?
		 */
		if ( !ne.getWorld().getName().equalsIgnoreCase( sw.getWorld().getName()) ) {
			
			//Problem. These dudes are not in the same world!
			return;
		} else if ( !p.getWorld().getName().equalsIgnoreCase( ne.getWorld().getName() ) ) {
			
			//Don't show as these dudes aren't in the same world.
			return;
			
		}
		
		if ( ( ne.getX() == 0D && ne.getY() == 0D && ne.getZ() == 0D ) || 
			( sw.getX() == 0D && sw.getY() == 0D && sw.getZ() == 0D ) ) withFlags = false;
		
		/**
		 * Get cuboid points
		 */
		List<Marker> l = getMarkers( ne, sw );
		
		
		/**
		 * Highlight points
		 */
		if ( !l.isEmpty() ) {
			for ( Marker m : l ) {
				m.highlight( p, withFlags );
			}
		}

		/**
		 * Store them so we can unhide them later.
		 * Hmm... I bet this would be better as metadata.
		 * TODO: Better as metadata?
		 */
		markers.put( p.getName(), l );		
		
	}
	
	/**
	 * Shortcut to show boundaries for zone
	 * @param p
	 * @param z
	 */
	public static void showZoneBoundaries( Player p, Zone z ) {
		
		showZoneBoundaries( p, z.getArea().ne(), z.getArea().sw() );
		
	}
	
	/**
	 * Hides any currently existing markers for player
	 * @param p
	 */
	public static void hideZoneBoundaries( Player p ) {
		
		if ( markers.containsKey( p.getName() ) ) {
			
			List<Marker> l = markers.get( p.getName() );
			
			if ( !l.isEmpty() ) {
				for ( Marker m : l ) {
					m.unhighlight( p );
				}
			}
			
			markers.get( p.getName() ).clear();
			
		}
		
	}
	
	/**
	 * Retrieve a list of Markers that define each point in the cuboid
	 * @param ne
	 * @param sw
	 * @return
	 */
	public static List<Marker> getMarkers( Location ne, Location sw ) {
		
		String worldName = ne.getWorld().getName();
		List<Marker> l = new ArrayList<Marker>();
		
		if ( ne != null && sw != null ) {
				
			int minX = Math.min( ne.getBlockX(), sw.getBlockX() ) ;
			int maxX = Math.max( ne.getBlockX(), sw.getBlockX() ) ;
			
			int minY = Math.min( ne.getBlockY(), sw.getBlockY() ) ;
			int maxY = Math.max( ne.getBlockY(), sw.getBlockY() ) ;
			
			int minZ = Math.min( ne.getBlockZ(), sw.getBlockZ() ) ;
			int maxZ = Math.max( ne.getBlockZ(),  sw.getBlockZ() );
			
			
			l.add( getMarker( worldName, minX, minY, minZ, minX+1, minZ+1 ) );
			l.add( getMarker( worldName, maxX, minY, minZ, maxX-1, minZ+1 ) );
			l.add( getMarker( worldName, minX, minY, maxZ, minX+1, maxZ-1 ) );
			l.add( getMarker( worldName, maxX, minY, maxZ, maxX-1, maxZ-1 ) );			

			l.add( getMarker( worldName, minX, maxY, minZ, minX+1, minZ+1 ) );
			l.add( getMarker( worldName, maxX, maxY, minZ, maxX-1, minZ+1 ) );
			l.add( getMarker( worldName, minX, maxY, maxZ, minX+1, maxZ-1 ) );
			l.add( getMarker( worldName, maxX, maxY, maxZ, maxX-1, maxZ-1 ) );
			
		} else if ( ne != null && sw==null ) {
			l.add( getMarker(  ne, false ) );
		} else if ( sw != null ) {
			l.add( getMarker(  sw, false ) );
			
		}
		
		return l;
		
	}
	
	/**
	 * Get a specific marker for location given
	 * @param l
	 * @return
	 */
	public static Marker getMarker( Location l ) {
		return getMarker( l, true );
	}
	public static Marker getMarker( Location l, boolean withFlags ) {
		return getMarker( l.getWorld().getName(), l.getBlockX(), l.getBlockY(), l.getBlockZ(), l.getBlockX(), l.getBlockZ() );
	}
	
	/**
	 * Get a marker for location, but generate the location dynamically
	 * @param worldName
	 * @param x
	 * @param y
	 * @param z
	 * @param xFlag
	 * @param zFlag
	 * @return
	 */
	public static Marker getMarker( String worldName, int x, int y, int z, int xFlag, int zFlag ) {
		return getMarker( worldName, x, y, z, xFlag, zFlag, true );
	}
	public static Marker getMarker( String worldName, int x, int y, int z, int xFlag, int zFlag, boolean withFlags ) {
		
		World world = Bukkit.getWorld( worldName );
		Block b1 = world.getBlockAt(x, y, z);

		Block b2 = world.getBlockAt( xFlag, y, z );
		Block b3 = world.getBlockAt( x, y, zFlag );
		
		return new Marker( b1, b2, b3 );
		
	}
	
	/**
	 * Close this baby down.
	 */
	public static void close() {
		
		if ( markers != null && !markers.isEmpty() ) {
			
			for ( String x : markers.keySet() ) {
				
				Player p = Bukkit.getPlayer(x);
				
				if ( p != null && p.isOnline() ) {
					hideZoneBoundaries( p );
				}
				
			}
			
			if ( markers.values().isEmpty() ) {
				for ( List<Marker> m : markers.values() ) {
					m.clear();
				}
			}
			markers.clear();
			
		}
		
	}
	
}
